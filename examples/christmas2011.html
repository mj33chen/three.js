<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - shadow map</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>

		<div id="info">
		A Christmas Experiment 2011 - shadowmap, particles + text effects + lens flare :) <br/>
		move camera with WASD / RF + mouse
		</div>

		<script src="../build/Three.js"></script>

		<script src="js/ShaderExtras.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>

		<script src="fonts/helvetiker_bold.typeface.js"></script>
		

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/BloomPass.js"></script>
		<script src="js/postprocessing/FilmPass.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

			var MARGIN = 100;

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
			var FLOOR = -250;

			var camera, controls, scene, renderer;
			var container, stats;

			var NEAR = 5, FAR = 3000;

			var sceneHUD, cameraOrtho, hudMaterial;

			var composer;
			// TODO Cut Scenes
			// 1. Text
			// 2. Snowman
			// 3. Wide + Lens flare
			
			// FX. Blurs, (50%)
			
			// Features?
			// Snow
			// Music
			// Card.
			

			var light;

			var clock = new THREE.Clock();

			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// SCENE CAMERA

				camera = new THREE.PerspectiveCamera( 23, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
				camera.position.set( 700, 50, 1900 );

				controls = new THREE.FirstPersonControls( camera );

				controls.lookSpeed = 0.02;
				controls.movementSpeed = 500;
				controls.noFly = false;
				controls.lookVertical = true;
				controls.constrainVertical = true;
				controls.verticalMin = 1.5;
				controls.verticalMax = 2.0;

				controls.lon = -110;

				// SCENE

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xfffefe, 1400, FAR );
				THREE.ColorUtils.adjustHSV( scene.fog.color, 0.02, -0.15, -0.65 );

				// LIGHTS

				var ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff );
				//light.position.set( 0, 1500, 1000 );
				//light.position.set( -800,000, -1000 );
				light.position.set( 300,400, -600 );
				light.target.position.set( 0, 0, 0 );
				light.castShadow = true;
				scene.add( light );

				createHUD();
				createScene();
				
				
				// lens flares

				var textureFlare0 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare0.png" );
				var textureFlare2 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare2.png" );
				var textureFlare3 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare3.png" );

				//addLight( 0.55, 0.825, 0.99, -800,0, 800);
				addLight( 0.08, 0.825, 0.99,    0, 0, 1000 );
				addLight( 0.995, 0.025, 0.99, light.position.x, light.position.y, light.position.z );
				
				// addLight( 0.55, 0.825, 0.99, 5000 , 0, 1000 );
				// addLight( 0.08, 0.825, 0.99,    0, 0, 1000 );
				// addLight( 0.995, 0.025, 0.99, 5000, 5000, 1000 );

				function addLight( h, s, v, x, y, z ) {

					var light = new THREE.PointLight( 0xffffff, 1.5, 4500 );
					light.position.set( x, y, z );
					scene.add( light );

					light.color.setHSV( h, s, v );

					var flareColor = new THREE.Color( 0xffffff );
					flareColor.copy( light.color );
					THREE.ColorUtils.adjustHSV( flareColor, 0, -0.5, 0.5 );

					var lensFlare = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor );

					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );

					lensFlare.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending );

					lensFlare.customUpdateCallback = lensFlareUpdateCallback;
					lensFlare.position = light.position;

					scene.add( lensFlare );

				}
				
				// RENDERER

				renderer = new THREE.WebGLRenderer( { clearColor: 0x000000, clearAlpha: 1, antialias: false } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.domElement.style.position = "relative";
				renderer.domElement.style.top = MARGIN + 'px';
				container.appendChild( renderer.domElement );

				renderer.setClearColor( scene.fog.color, 1 );
				renderer.autoClear = false;

				renderer.shadowCameraNear = 3;
				renderer.shadowCameraFar = camera.far;
				renderer.shadowCameraFov = 50;

				renderer.shadowMapBias = 0.0039;
				renderer.shadowMapDarkness = 0.3;
				renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
				renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;

				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = true;
				
				// for flare
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.physicallyBasedShading = true;
				
				
				// POSTPROCESSING
				
				// Get examples from post_proces, particles shapes, etc. text, dynamic terrian
				
				console.log(renderer);
				renderer.autoClear = false;

				var renderScene = new THREE.RenderPass( scene, camera );
				
				
				// var effectBloom = new THREE.BloomPass( 0.25 );
				// var effectFilm = new THREE.FilmPass( 0.5, 0.125, 2048, false );
				var effectFXAA = new THREE.ShaderPass( THREE.ShaderExtras[ "fxaa" ] );				
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / SCREEN_WIDTH, 1 / SCREEN_HEIGHT );
				
				// effectFilm.renderToScreen = true;
				
				// var hblur = new THREE.ShaderPass( THREE.ShaderExtras[ "horizontalBlur" ] );
				// var vblur = new THREE.ShaderPass( THREE.ShaderExtras[ "verticalBlur" ] );
				// 
				// hblur.uniforms[ 'h' ].value =  1 / SCREEN_WIDTH;
				// vblur.uniforms[ 'v' ].value =  1 / SCREEN_HEIGHT;
				
				hblur = new THREE.ShaderPass( THREE.ShaderExtras[ "horizontalTiltShift" ] );
				vblur = new THREE.ShaderPass( THREE.ShaderExtras[ "verticalTiltShift" ] );

				var bluriness = 6;

				hblur.uniforms[ 'h' ].value = bluriness / SCREEN_WIDTH;
				vblur.uniforms[ 'v' ].value = bluriness / SCREEN_HEIGHT;

				hblur.uniforms[ 'r' ].value = vblur.uniforms[ 'r' ].value = 0.5;
				
				
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderScene );
				
				composer.addPass( hblur );
				composer.addPass( vblur );
				//composer.addPass( effectFXAA );
				//effectFXAA.renderToScreen = true;
				
				//composer.addPass( renderModel );
				//composer.addPass( effectFXAA );
				//composer.addPass( effectBloom );
				//composer.addPass( effectFilm );
				composer.passes[composer.passes.length-1].renderToScreen = true;
				console.log('ping', composer, scene, camera);

				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

			}

			function createHUD() {

				cameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2,  SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10, 1000 );
				cameraOrtho.position.z = 10;

				var shader = THREE.ShaderExtras[ "screen" ];
				var uniforms = new THREE.UniformsUtils.clone( shader.uniforms );

				hudMaterial = new THREE.ShaderMaterial( { vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader, uniforms: uniforms } );

				var hudGeo = new THREE.PlaneGeometry( SHADOW_MAP_WIDTH / 2, SHADOW_MAP_HEIGHT / 2 );
				var hudMesh = new THREE.Mesh( hudGeo, hudMaterial );
				hudMesh.position.x = ( SCREEN_WIDTH - SHADOW_MAP_WIDTH / 2 ) * -0.5;
				hudMesh.position.y = ( SCREEN_HEIGHT - SHADOW_MAP_HEIGHT / 2 ) * -0.5;

				sceneHUD = new THREE.Scene();
				sceneHUD.add( hudMesh );

				cameraOrtho.lookAt( sceneHUD.position );

			}

			function createScene( ) {

				// GROUND

				var geometry = new THREE.PlaneGeometry( 100, 100 );
				var planeMaterial = new THREE.MeshLambertMaterial( { color: 0xfefefe } ); //0xffdd99
				THREE.ColorUtils.adjustHSV( planeMaterial.color, 0, 0, 0.9 );
				planeMaterial.ambient = planeMaterial.color;

				var ground = new THREE.Mesh( geometry, planeMaterial );

				ground.position.set( 0, FLOOR, 0 );
				ground.rotation.x = -Math.PI/2;
				ground.scale.set( 100, 100, 100 );

				ground.castShadow = false;
				ground.receiveShadow = true;

				scene.add( ground );

				// TEXT
				
				faceMaterial = new THREE.MeshFaceMaterial();

				textMaterialFront = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } );
				textMaterialSide = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } );

				var textGeo = new THREE.TextGeometry( "CHRISTMAS", {

					size: 200,
					height: 50,
					curveSegments: 12,

					font: "helvetiker",
					weight: "bold",
					style: "normal",

					bevelThickness: 2,
					bevelSize: 5,
					bevelEnabled: true

				//});
				
					,material: 0,
					extrudeMaterial: 1

				});

				textGeo.materials = [ textMaterialFront, textMaterialSide ];

				textGeo.computeBoundingBox();
				
				//
				//textGeo.computeVertexNormals();

				
				var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff, ambient: 0xaa0000 } );
				var snowMaterial = new THREE.MeshPhongMaterial( { color: 0xfefefe, specular: 0xfefefe, ambient: 0xdedede } );

				var textMesh = new THREE.Mesh( textGeo, planeMaterial ); //planeMaterial
				textMesh.position.x = centerOffset;
				//textMesh.position.y = FLOOR + 67;
				textMesh.position.y = FLOOR + 10;

				textMesh.castShadow = true;
				textMesh.receiveShadow = true;

				scene.add( textMesh );

				// Steps Cubes

				var mesh = new THREE.Mesh( new THREE.CubeGeometry( 1800, 220, 150 ), planeMaterial );

				mesh.position.y = FLOOR - 50;
				mesh.position.z = 20;

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				//scene.add( mesh );

				var mesh = new THREE.Mesh( new THREE.CubeGeometry( 2000, 170, 250 ), planeMaterial ); //textMaterial

				mesh.position.y = FLOOR - 50;
				mesh.position.z = 20;

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				//scene.add( mesh );
				
				
				// SNOW MAN
				
				var head = new THREE.OctahedronGeometry( 100, 4 ); //SphereGeometry
				var body = new THREE.OctahedronGeometry( 140, 4 ); // new THREE.SphereGeometry( 140, 20, 20 );
				body.applyMatrix( new THREE.Matrix4().setScale( 1, 0.8, 1 ) );
				
				
				var headMesh = new THREE.Mesh( head, planeMaterial ); //planeMaterial
				var bodyMesh = new THREE.Mesh( body, planeMaterial ); //snowMaterial
				
				bodyMesh.position.y -= 180;
				
				snowman = new THREE.Object3D();
				//snowman.position.y = -100;
				snowman.position.set(-800,0, 400);
				
				headMesh.castShadow = !false;
				headMesh.receiveShadow = !false;
				
				bodyMesh.castShadow = !false;
				bodyMesh.receiveShadow = !false;
				
				// Create hands for snowman.
				
				
				//snowman.castShadow = false;
				//snowman.receiveShadow = false;
				
				//headMesh.position.set(-700,20, 400);
				//scene.add(headMesh);
				
				snowman.add(headMesh);
				snowman.add(bodyMesh);
				
				scene.add(snowman);

			}
			
			 function lensFlareUpdateCallback( object ) {

				var f, fl = object.lensFlares.length;
				var flare;
				var vecX = -object.positionScreen.x * 2;
				var vecY = -object.positionScreen.y * 2;


				for( f = 0; f < fl; f++ ) {

					   flare = object.lensFlares[ f ];

					   flare.x = object.positionScreen.x + vecX * flare.distance;
					   flare.y = object.positionScreen.y + vecY * flare.distance;

					   flare.rotation = 0;

				}

				object.lensFlares[ 2 ].y += 0.025;
				object.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + 45 * Math.PI / 180;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var delta = clock.getDelta();

				controls.update( delta );

				renderer.clear();
				renderer.render( scene, camera );
				
				
				//composer.render( 0.05 );
				
				// Render debug HUD with shadow map
				// setInterval(function() {light.position.y += 100 ; }, 200);
				//hudMaterial.uniforms.tDiffuse.texture = renderer.shadowMapPlugin.shadowMap[0];
				//renderer.render( sceneHUD, cameraOrtho );

			}

		</script>

	</body>
</html>
