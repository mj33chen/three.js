<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - shadow map</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>

		<div id="info">
		A Christmas Experiment 2011 - shadowmap, particles + text effects + lens flare :) <br/>
		move camera with WASD / RF + mouse
		</div>

		<script src="../build/Three.js"></script>

		<script src="js/ShaderExtras.js"></script>
		
		<script src="js/Tween.js"></script>
		<script src="js/Sparks.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>
		
		<script src="js/fps2.js"></script>

		<script src="fonts/helvetiker_bold.typeface.js"></script>
		

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/BloomPass.js"></script>
		<script src="js/postprocessing/FilmPass.js"></script>
		
		<script type="x-shader/x-vertex" id="vertexshader">

					attribute float size;
			attribute vec3 pcolor;

			varying vec3 vColor;

			void main() {

				vColor = pcolor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 200.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				vec4 outColor = texture2D( texture, gl_PointCoord );

				gl_FragColor = outColor * vec4( vColor, 1.0 );

			}

		</script>
		
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

			var MARGIN = 100;

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
			var FLOOR = -250;

			var camera, controls, scene, renderer;
			var container, stats;

			var NEAR = 5, FAR = 3000;

			var sceneHUD, cameraOrtho, hudMaterial;

			var composer;
			
			var particleCloud, sparksEmitter, attributes, particleProducer;
			
			// TODO Cut Scenes
			// 1. Text
			// 2. Snowman
			// 3. Wide + Lens flare
			
			// FX. Blurs, (50%)
			
			// Frost Fog Ground
			
			// Bouncing Snowman?
			
			// Features?
			// Snow
			// Music
			// Card.
			
			// snow on ground?
			// shadows direction? view-source:http://alteredqualia.com/three/examples/webgl_shadowmap_particles.html
			
			// Camera Limits?
			
			// PARTICLES TODO: Dead box, eg. below floor. Attractors via areas? Particles via Canvas/Extrude?
			// Turbulence: airtightinteractive.com/demos/js/snowbox/js/SnowBox.js
			// Shapes
			// http://airtightinteractive.com/demos/js/hello/
			// LookaT flint and stardusts.
			//http://blog.cjcat.net/2011/02/stardust-touch-ups-for-brilliant-scenary/
			
			// http://flintparticles.org/examples/rain collision
			
			
			// Music Online.
			
			var light;

			var clock = new THREE.Clock();

			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// SCENE CAMERA

				camera = new THREE.PerspectiveCamera( 23, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
				camera.position.set( 700, 50, 1800 ); //700, 50, 1900
				
				
				
				controls = new THREE.FirstPersonControls( camera );

				// controls.lookSpeed = 0.01;
				// controls.movementSpeed = 100;
				controls.lookSpeed = 0.02;
				controls.movementSpeed = 500;

				controls.noFly = false;
				controls.lookVertical = true;
				controls.constrainVertical = true;
				controls.verticalMin = 1.5;
				controls.verticalMax = 2.0;

				//controls.lon = -110;
				controls.lat = 64.64555278652584;
				controls.lon=  246.43799999999848;

				// SCENE

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xfffefe, 1400, FAR );
				THREE.ColorUtils.adjustHSV( scene.fog.color, 0.02, -0.15, -0.65 );

				// LIGHTS

				var ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff );
				//light.position.set( 0, 1500, 1000 ); // front light
				light.position.set( -800,000, -1000 ); // morning light
				
				//light.position.set( 300,400, -600 ); // backlight
				
				tweeny = new TWEEN.Tween(light.position).to({
					x:300,y:400, z:-600
					}, 10000).
					start();
					
					
					// .chain(new TWEEN.Tween(light.position).to({
					// 						x:800,y:600, z:1000
					// 						}, 10000));
					// 					
					//.easing(TWEEN.Easing.Elastic.EaseInOut)
				
				
				// var lightpos = {x:-800, y:000, z:-1000};
				// tweeny = new TWEEN.Tween(lightpos).to({
				// 	x:300,y:400, z:-600
				// 	}, 4000).onUpdate(function() {
				// 		console.log('tet', lightpos);
				// 		light.position.set(lightpos.x, lightpos.y, lightpos.z);
				// 	}).start(); //.easing(TWEEN.Easing.Elastic.EaseInOut)
				
				
				light.target.position.set( 0, 0, 0 );
				light.castShadow = true;
				scene.add( light );

				createHUD();
				createScene();
				
				
				// lens flares

				var textureFlare0 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare0.png" );
				var textureFlare2 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare2.png" );
				var textureFlare3 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare3.png" );

				//addLight( 0.55, 0.825, 0.99, -800,0, 800);
				//addLight( 0.08, 0.825, 0.99,    0, 0, 1000 );
				//addLight( 0.995, 0.025, 0.99, light.position.x, light.position.y, light.position.z );
				addLight( 0.995, 0.025, 0.99, light.position );
				
				// addLight( 0.55, 0.825, 0.99, 5000 , 0, 1000 );
				// addLight( 0.08, 0.825, 0.99,    0, 0, 1000 );
				// addLight( 0.995, 0.025, 0.99, 5000, 5000, 1000 );

				function addLight( h, s, v, pos) { //x, y, z 


					var light = new THREE.PointLight( 0xffffff, 1.5, 4500 );
					//light.position.set( x, y, z );
					light.position = pos;
					
					scene.add( light );

					light.color.setHSV( h, s, v );

					var flareColor = new THREE.Color( 0xffffff );
					flareColor.copy( light.color );
					THREE.ColorUtils.adjustHSV( flareColor, 0, -0.5, 0.5 );

					var lensFlare = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor );

					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );

					lensFlare.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending );

					lensFlare.customUpdateCallback = lensFlareUpdateCallback;
					lensFlare.position = light.position;

					scene.add( lensFlare );

				}
				
				// PARTICLE SYSTEMS
				
				var particlePoolCount = 20000;

				var particles = new THREE.Geometry();
				
				function newVertex( x, y, z ) {
					return new THREE.Vertex( new THREE.Vector3( x, y, z ) );
				}
				
				
				// This pool is for grabbing a particle used in Three.js
				// It doesn't store any stuff, just indinces 
				var ParticlePool = {

					__pools: [],
					__forloan: [],

					// Get a new Vector / Borrow

					get: function() {

						if ( this.__forloan.length > 0 ) {
							
							return this.__forloan.pop();
							
						}

						console.log( "pool ran out!" );
						
						var r = this.__pools[Math.floor(Math.random()*this.__pools.length)];
						if (r.stolen) {
							r.stolen++;
						} else {
							r.stolen = 1;
						}

						return r;

					},

					// Release a vector back into the pool, Return / add

					add: function( v ) {
						this.__forloan.push( v );
						this.__pools.push( v );

					},
					
					return: function( v ) {
						if (!v.stolen) {
							this.__forloan.push( v );
						} else {
							v.stolen--;
						}

					}
					
					

				};
				
				for ( i = 0; i < particlePoolCount; i ++ ) {

					particles.vertices.push( newVertex( Math.random() * 200 - 100, Math.random() * 100 + 150, Math.random() * 50 ) );
					ParticlePool.add( i );
					
				}
				
				// Create pools of vectors

				var sprite = generateSprite() ;

				texture = new THREE.Texture( sprite );
				texture.needsUpdate = true;

				function generateSprite() {
					// Generate a texture
					var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;

					var context = canvas.getContext( '2d' );

					context.beginPath();
					context.arc( 64, 64, 60, 0, Math.PI * 2, false) ;
					context.closePath();

					context.lineWidth = 0.5; //0.05
					context.stroke();
					context.restore();

					var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );

					gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
					gradient.addColorStop( 0.2, 'rgba(255,255,255,1)' );
					gradient.addColorStop( 0.4, 'rgba(200,200,200,1)' );
					gradient.addColorStop( 1, 'rgba(0,0,0,1)' );

					context.fillStyle = gradient;

					context.fill();

					return canvas;

				}
				
				attributes = {

					size:  { type: 'f', value: [] },
					pcolor: { type: 'c', value: [] }

				};

				var uniforms = {

					texture:   { type: "t", value: 0, texture: texture }

				};

				var shaderMaterial = new THREE.ShaderMaterial( {

					uniforms: 		uniforms,
					attributes:     attributes,

					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					blending: 		THREE.AdditiveBlending, //AdditiveBlending THREE.Subtractive
					depthWrite:		false,
					transparent:	true

				});

				particleCloud = new THREE.ParticleSystem( particles, shaderMaterial );

				particleCloud.castShadow = true;
				particleCloud.receiveShadow = true;
				
				particleCloud.dynamic = true;
				//particleCloud.sortParticles = true;

				var vertices = particleCloud.geometry.vertices;
				var values_size = attributes.size.value; // Particle Size
				var values_color = attributes.pcolor.value; // Particle Color

				for( var v = 0; v < vertices.length; v ++ ) {

					values_size[ v ] = 30;
					values_color[ v ] = new THREE.Color( 0xffffff );
					//values_color[ v ].setHSV( 0, 0, 0 );
					particles.vertices[ v ].position.set( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );

				}

				scene.add( particleCloud );
				//particleCloud.y = 800;
				
				var onParticleCreated = function( p ) {
					
					var target = ParticlePool.get();
					
					p.target = target;	
					
					
					var position = p.position;
					p.target.position = position;

					var target = p.target;
					
					var shadow = ParticlePool.get();
					p.shadow = shadow;

					if ( target ) {
						particles.vertices[ target ].position = p.position;

						values_color[ target ].setHSV( 0, 0, 0.4 + Math.random() * 0.4 );
						values_size[ target ] = 10 +  Math.random() * 80;
						
						values_color[ shadow ].setHSV( 0.4, 0, 1 );
						//values_color[ shadow ].setRGB( 10, 10, 100 );
						values_size[ shadow ] = 50; //values_size[ target ];
						
					};

				};

				var onParticleDead = function( particle ) {

					var target = particle.target;

					if ( target ) {

						// Hide the particle

						values_color[ target ].setHSV( 0, 0, 0 );
						particles.vertices[ target ].position.set( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );


						var shadow = particle.shadow;
						
						values_color[ shadow ].setHSV( 0, 0, 0 );
						particles.vertices[ shadow ].position.set( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );

						// Mark particle system as available by returning to pool

						ParticlePool.return( particle.target );
						ParticlePool.return( shadow );

					}

				};
				
				var onParticleUpdate = function( particle ) {
					
					particles.vertices[ particle.shadow ].position.set(
						particle.position.x,
						FLOOR + 10,
						particle.position.z);
					// SHould do some projection from Light to particles to floor.
					
				}
				
				particleProducer = new SPARKS.SteadyCounter( 50 );

				sparksEmitter = new SPARKS.Emitter( particleProducer );

				emitterpos = new THREE.Vector3( 0, 0, 0 );
				
				var zone = new SPARKS.ParallelogramZone( 
					new THREE.Vector3(-1000,500,-1000), 
					new THREE.Vector3(2000,0,0),
					new THREE.Vector3(0,0,2000)	);

				sparksEmitter.addInitializer(new SPARKS.Position( zone ) );
				sparksEmitter.addInitializer(new SPARKS.Lifetime(5,10));

				sparksEmitter.addInitializer( new SPARKS.Velocity( new SPARKS.PointZone( new THREE.Vector3( 0, -100, 50 ) ) ) );

				sparksEmitter.addAction( new SPARKS.Age() );
				sparksEmitter.addAction( new SPARKS.Move() );
				
				sparksEmitter.addAction( new SPARKS.Accelerate( 40, -100, 50  ) );				
				sparksEmitter.addAction( new SPARKS.RandomDrift( 500 * 1, 100, 500* 1 ) );


				sparksEmitter.addCallback( "created", onParticleCreated );
				sparksEmitter.addCallback( "dead", onParticleDead );
				sparksEmitter.addCallback( "updated", onParticleUpdate );
				
				sparksEmitter.start();

				// RENDERER

				renderer = new THREE.WebGLRenderer( { clearColor: 0x000000, clearAlpha: 1, antialias: false } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.domElement.style.position = "relative";
				renderer.domElement.style.top = MARGIN + 'px';
				container.appendChild( renderer.domElement );

				renderer.setClearColor( scene.fog.color, 1 );
				renderer.autoClear = false;

				renderer.shadowCameraNear = 3;
				renderer.shadowCameraFar = camera.far;
				renderer.shadowCameraFov = 50;

				//renderer.shadowMapBias = 0.0039;
				renderer.shadowMapDarkness = 0.3;
				renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
				renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;

				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = true;
				
				// for flare
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.physicallyBasedShading = true;
				// 				
				
				// POSTPROCESSING
				
				// Get examples from post_proces, particles shapes, etc. text, dynamic terrian
				
				renderer.autoClear = false;

				var renderScene = new THREE.RenderPass( scene, camera );
				
				
				// var effectBloom = new THREE.BloomPass( 0.25 );
				// var effectFilm = new THREE.FilmPass( 0.5, 0.125, 2048, false );
				var effectFXAA = new THREE.ShaderPass( THREE.ShaderExtras[ "fxaa" ] );				
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / SCREEN_WIDTH, 1 / SCREEN_HEIGHT );
				
				// effectFilm.renderToScreen = true;
				
				// var hblur = new THREE.ShaderPass( THREE.ShaderExtras[ "horizontalBlur" ] );
				// var vblur = new THREE.ShaderPass( THREE.ShaderExtras[ "verticalBlur" ] );
				// 
				// hblur.uniforms[ 'h' ].value =  1 / SCREEN_WIDTH;
				// vblur.uniforms[ 'v' ].value =  1 / SCREEN_HEIGHT;
				
				hblur = new THREE.ShaderPass( THREE.ShaderExtras[ "horizontalTiltShift" ] );
				vblur = new THREE.ShaderPass( THREE.ShaderExtras[ "verticalTiltShift" ] );

				var bluriness = 6;

				hblur.uniforms[ 'h' ].value = bluriness / SCREEN_WIDTH;
				vblur.uniforms[ 'v' ].value = bluriness / SCREEN_HEIGHT;

				hblur.uniforms[ 'r' ].value = vblur.uniforms[ 'r' ].value = 0.5;
				
				renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBufer: false };
				renderTarget = new THREE.WebGLRenderTarget( SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters );
				
				
				composer = new THREE.EffectComposer( renderer, renderTarget );
				//composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderScene );
				
				composer.addPass( hblur );
				composer.addPass( vblur );
				//composer.addPass( effectFXAA );
				//effectFXAA.renderToScreen = true;
				
				//composer.addPass( renderModel );
				//composer.addPass( effectFXAA );
				//composer.addPass( effectBloom );
				//composer.addPass( effectFilm );
				composer.passes[composer.passes.length-1].renderToScreen = true;


				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

			}

			function createHUD() {

				cameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2,  SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10, 1000 );
				cameraOrtho.position.z = 10;

				var shader = THREE.ShaderExtras[ "screen" ];
				var uniforms = new THREE.UniformsUtils.clone( shader.uniforms );

				hudMaterial = new THREE.ShaderMaterial( { vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader, uniforms: uniforms } );

				var hudGeo = new THREE.PlaneGeometry( SHADOW_MAP_WIDTH / 2, SHADOW_MAP_HEIGHT / 2 );
				var hudMesh = new THREE.Mesh( hudGeo, hudMaterial );
				hudMesh.position.x = ( SCREEN_WIDTH - SHADOW_MAP_WIDTH / 2 ) * -0.5;
				hudMesh.position.y = ( SCREEN_HEIGHT - SHADOW_MAP_HEIGHT / 2 ) * -0.5;

				sceneHUD = new THREE.Scene();
				sceneHUD.add( hudMesh );

				cameraOrtho.lookAt( sceneHUD.position );

			}

			function createScene( ) {

				// GROUND

				var geometry = new THREE.PlaneGeometry( 100, 100 );
				var planeMaterial = new THREE.MeshLambertMaterial( { color: 0xfefefe } ); //0xffdd99
				THREE.ColorUtils.adjustHSV( planeMaterial.color, 0, 0, 0.9 );
				planeMaterial.ambient = planeMaterial.color;

				var ground = new THREE.Mesh( geometry, planeMaterial );

				ground.position.set( 0, FLOOR, 0 );
				ground.rotation.x = -Math.PI/2;
				ground.scale.set( 100, 100, 100 );

				ground.castShadow = false;
				ground.receiveShadow = true;

				scene.add( ground );

				// TEXT
				
				faceMaterial = new THREE.MeshFaceMaterial();

				textMaterialFront = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } );
				textMaterialSide = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } );

				var textGeo = new THREE.TextGeometry( "CALEB KOO", {
					//ROSE MARIE

					size: 200,
					height: 50,
					curveSegments: 12,

					font: "helvetiker",
					weight: "bold",
					style: "normal",

					bevelThickness: 2,
					bevelSize: 5,
					bevelEnabled: true

				//});
				
					,material: 0,
					extrudeMaterial: 1

				});

				textGeo.materials = [ textMaterialFront, textMaterialSide ];

				textGeo.computeBoundingBox();
				
				//
				textGeo.computeVertexNormals();

				
				var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff, ambient: 0xaa0000 } );
				var snowMaterial = new THREE.MeshPhongMaterial( { color: 0xfefefe, specular: 0xfefefe, ambient: 0xdedede } );

				var textMesh = new THREE.Mesh( textGeo, faceMaterial ); //planeMaterial faceMaterial 
				textMesh.position.x = centerOffset;
				//textMesh.position.y = FLOOR + 67;
				textMesh.position.y = FLOOR + 10;

				textMesh.castShadow = true;
				textMesh.receiveShadow = !true;

				scene.add( textMesh );

				// Steps Cubes

				var mesh = new THREE.Mesh( new THREE.CubeGeometry( 1800, 220, 150 ), planeMaterial );

				mesh.position.y = FLOOR - 50;
				mesh.position.z = 20;

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				//scene.add( mesh );

				var mesh = new THREE.Mesh( new THREE.CubeGeometry( 2000, 170, 250 ), planeMaterial ); //textMaterial

				mesh.position.y = FLOOR - 50;
				mesh.position.z = 20;

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				//scene.add( mesh );
				
				
				// SNOW MAN
				
				var head = new THREE.OctahedronGeometry( 100, 4 ); //SphereGeometry
				var body = new THREE.OctahedronGeometry( 140, 4 ); // new THREE.SphereGeometry( 140, 20, 20 );
				body.applyMatrix( new THREE.Matrix4().setScale( 1, 0.8, 1 ) );
				
				
				var headMesh = new THREE.Mesh( head, planeMaterial ); //planeMaterial
				var bodyMesh = new THREE.Mesh( body, planeMaterial ); //snowMaterial
				
				bodyMesh.position.y -= 180;
				
				snowman = new THREE.Object3D();
				//snowman.position.y = -100;
				snowman.position.set(-800,0, 400);
				
				headMesh.castShadow = !false;
				headMesh.receiveShadow = !false;
				
				bodyMesh.castShadow = !false;
				bodyMesh.receiveShadow = !false;
				
				// Create hands for snowman.
				
				
				snowman.castShadow = false;
				snowman.receiveShadow = false;
				
				//headMesh.position.set(-700,20, 400);
				//scene.add(headMesh);
				
				snowman.add(headMesh);
				snowman.add(bodyMesh);
				
				scene.add(snowman);

			}
			
			 function lensFlareUpdateCallback( object ) {

				var f, fl = object.lensFlares.length;
				var flare;
				var vecX = -object.positionScreen.x * 2;
				var vecY = -object.positionScreen.y * 2;


				for( f = 0; f < fl; f++ ) {

					   flare = object.lensFlares[ f ];

					   flare.x = object.positionScreen.x + vecX * flare.distance;
					   flare.y = object.positionScreen.y + vecY * flare.distance;

					   flare.rotation = 0;

				}

				object.lensFlares[ 2 ].y += 0.025;
				object.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + 45 * Math.PI / 180;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}
			
			var minDelta = Number.POSITIVE_INFINITY, maxDelta = Number.NEGATIVE_INFINITY;
			

			function render() {

				var delta = clock.getDelta();
				minDelta = Math.min(minDelta, delta);
				maxDelta = Math.max(maxDelta, delta);
				// 0.015, 0.4
				
				//controls.update( delta );
				//console.log(delta);
				controls.update( 0.025 );
				
				particleCloud.geometry.__dirtyVertices = true;

				attributes.size.needsUpdate = true;
				attributes.pcolor.needsUpdate = true;
				
				TWEEN.update();
				
				
				renderer.clear();
				//renderer.render( scene, camera );
				composer.render( 0.05 );
				
				// Render debug HUD with shadow map
				// setInterval(function() {light.position.y += 100 ; }, 200);
				// hudMaterial.uniforms.tDiffuse.texture = renderer.shadowMapPlugin.shadowMap[0];
				// renderer.render( sceneHUD, cameraOrtho );
				
			}

			
			
			

		</script>

	</body>
</html>
